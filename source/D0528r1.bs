<pre class='metadata'>
Title: The Curious Case of Padding Bits, Featuring Atomic Compare-and-Exchange
Shortname: D0528
Revision: 1
Audience: SG1, LEWG, LWG, CWG
Status: D
Group: WG21
URL: http://wg21.link/D0528r1
!Source: <a href="https://github.com/jfbastien/papers/blob/master/source/D0528r1.bs">github.com/jfbastien/papers/blob/master/source/D0528r1.bs</a>
Editor: JF Bastien, Apple, jfbastien@apple.com
Editor: Michael Spencer, Sony Playstation, bigcheesegs@gmail.com
Abstract: Compare-and-exchange on a struct with padding bits should Just Work.
Date: 2018-02-06
Markup Shorthands: markdown yes
</pre>

This issue has been discussed by the authors at every recent Standards meetings,
yet a full solution has been elusive despite helpful proposals. We believe that
this proposal can fix this oft-encountered problem once and for all.

[[P0528r0]] details extensive background on this problem (not repeated here),
and proposed standardizing a trait, `has_padding_bits`, and using it on
`compare_and_exchange_*`. This paper applies EWG guidance and simply adds a
note.


Edit History {#edit}
============

r0 → r1 {#r0r1}
-------

In Albuquerque, EWG voted to make the padding bits of `atomic` and the incoming
value of `T` have a consistent value for the purposes of read/modify/write
atomic operations?

Purposefully not addressed in this paper:

  * `union` with padding bits
  * Types with trap representations

Proposed Wording {#word}
================

In Operations on atomic types [**atomics.types.operations**].

❡3:

<blockquote>

<xmp>constexpr atomic(T desired) noexcept;</xmp>

*Effects:* Initializes the object with the value `desired`<ins>, replacing bits
which never participate in the object's representation with an
implementation-defined value</ins>. Initialization is not an atomic
operation.

[*Note:* It is possible to have an access to an atomic object `A` race with its
construction, for example by communicating the address of the just-constructed
object `A` to another thread via `memory_order::relaxed` operations on a
suitable atomic pointer variable, and then immediately accessing `A` in the
receiving thread. This results in undefined behavior. —*end note*]

</blockquote>

❡4 and ❡5:

<blockquote>

<xmp>
  void store(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
  void store(T desired, memory_order order = memory_order::seq_cst) noexcept;
</xmp>

*Requires:* The `order` argument shall not be
`memory_order::consume`, `memory_order::acquire`, nor
`memory_order::acq_rel`.

*Effects:* Atomically replaces the value pointed to by `this` with the value of
`desired`<ins>, replacing bits which never participate in the object's
representation with an implementation-defined value</ins>. Memory is affected
according to the value of `order`.

</blockquote>

❡15 and ❡16:

<blockquote>

<xmp>
  T exchange(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
  T exchange(T desired, memory_order order = memory_order::seq_cst) noexcept;
</xmp>

*Effects:* Atomically replaces the value pointed to by `this` with
`desired`<ins>, replacing bits which never participate in the object's
representation with an implementation-defined value</ins>. Memory is affected
according to the value of `order`. These operations are atomic read-modify-write
operations.

*Returns:* Atomically returns the value pointed to by `this` immediately
before the effects.

</blockquote>

❡17 and onwards:

<blockquote>

*Requires:* The `failure` argument shall not be `memory_order::release` nor
`memory_order::acq_rel`.

*Effects:* Retrieves the value in `expected`. <ins>Bits in the retrieved value
which never participate in the object's representation are set to a value
consistent to that previously stored in the atomic object.</ins> It then
atomically compares the contents of the memory pointed to by `this` for equality
with that previously retrieved from `expected`, and if true, replaces the
contents of the memory pointed to by `this` with that in `desired`. If and only
if the comparison is true, memory is affected according to the value of
`success`, and if the comparison is false, memory is affected according to the
value of `failure`. When only one `memory_order` argument is supplied, the value
of `success` is `order`, and the value of `failure` is `order` except that a
value of `memory_order::acq_rel` shall be replaced by the value
`memory_order::acquire` and a value of `memory_order::release` shall be replaced
by the value `memory_order::relaxed`. If and only if the comparison is false
then, after the atomic operation, the contents of the memory in `expected` are
replaced by the value read from the memory pointed to by `this` during the
atomic comparison. If the operation returns `true`, these operations are atomic
read-modify-write operations on the memory pointed to by `this`. Otherwise,
these operations are atomic load operations on that memory.

*Returns:* The result of the comparison.

[*Note:*

  For example, the effect of `compare_exchange_strong` is
  
  <xmp>
  
    if (memcmp(this, &expected, sizeof(*this)) == 0)
      memcpy(this, &desired, sizeof(*this));
    else
       memcpy(expected, this, sizeof(*this));

  </xmp>

—*end note*]

[*Example:*

  The expected use of the compare-and-exchange operations is as follows. The
  compare-and-exchange operations will update `expected` when another iteration
  of the loop is needed.
  
  <xmp>

    expected = current.load();
    do {
      desired = function(expected);
    } while (!current.compare_exchange_weak(expected, desired));

  </xmp>
  
—*end example*]
  
[*Example:*

  Because the expected value is updated only on failure, code releasing the
  memory containing the `expected` value on success will work. E.g. list head
  insertion will act atomically and would not introduce a data race in the
  following code:
  
  <xmp>

    do {
      p->next = head; // make new list node point to the current head
    } while (!head.compare_exchange_weak(p->next, p)); // try to insert

  </xmp>
  
—*end example*]

Implementations should ensure that weak compare-and-exchange operations do not
consistently return `false` unless either the atomic object has value different
from `expected` or there are concurrent modifications to the atomic object.


*Remarks:* A weak compare-and-exchange operation may fail spuriously. That is,
even when the contents of memory referred to by `expected` and `this` are equal,
it may return `false` and store back to `expected` the same memory contents that
were originally there.

[*Note:*

  This spurious failure enables implementation of compare-and-exchange on a
  broader class of machines, e.g., load-locked store-conditional machines. A
  consequence of spurious failure is that nearly all uses of weak
  compare-and-exchange will be in a loop. When a compare-and-exchange is in a
  loop, the weak version will yield better performance on some platforms. When a
  weak compare-and-exchange would require a loop and a strong one would not, the
  strong one is preferable.

—*end note*]

[*Note:*

  The `memcpy` and `memcmp` semantics of the compare-and-exchange operations may
  result in failed comparisons for values that compare equal with `operator==`
  if the underlying type has padding bits<ins> which may participate in the
  object's representation (such as a `union` containing a type with padding
  bits)</ins>, trap bits, or alternate representations of the same value.

—*end note*]

</blockquote>


In Non-member functions [**atomics.nonmembers**], ❡2:

<blockquote>

<xmp>
  template<class T>
    void atomic_init(volatile atomic<T>* object, typename atomic<T>::value_type desired) noexcept;
  template<class T>
    void atomic_init(atomic<T>* object, typename atomic<T>::value_type desired) noexcept;
</xmp>

*Effects:* Non-atomically initializes `*object` with value `desired`<ins>,
replacing bits which never participate in the object's representation with an
implementation-defined value</ins>. This function shall only be applied to
objects that have been default constructed, and then only once.

</blockquote>
